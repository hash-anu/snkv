#!/bin/sh
# gen_snkv_header.sh — Generate snkv.h, a single-file amalgamation.
#
# Usage:
#   sh scripts/gen_snkv_header.sh > snkv.h
#
# The output contains the full public API + all implementation.
# Include it from exactly ONE .c file to compile the entire library:
#
#   #include "snkv.h"
#   int main() { ... }
#
# Compile: gcc myapp.c -o myapp        (no -Iinclude, no libsnkv.a)

SRCDIR="$(cd "$(dirname "$0")/.." && pwd)"
INCDIR="$SRCDIR/include"
CDIR="$SRCDIR/src"

# Strip lines that include internal project headers.
# Keeps all system <...> includes except <sqliteInt.h> (used by os_kv.c).
# Exception: #include "windows.h" (used by os_win.h) is converted to
# #include <windows.h> so it survives into the amalgamation.
strip_local_includes() {
  sed \
    -e 's/^\([[:space:]]*#[[:space:]]*include[[:space:]]*\)"windows\.h"/\1<windows.h>/' \
    -e '/^[[:space:]]*#[[:space:]]*include[[:space:]]*".*"/d' \
    -e '/^[[:space:]]*#[[:space:]]*include[[:space:]]*<sqliteInt\.h>/d'
}

emit() {
  echo "/****** $1 ******/"
  strip_local_includes < "$2"
  echo ""
}

# Emit a range of lines from a file (1-based, inclusive).
# Usage: emit_lines FILE START END
emit_lines() {
  sed -n "${2},${3}p" "$1" | strip_local_includes
}

# ============================================================
# Part 1: File preamble + public API
# ============================================================
cat << 'PREAMBLE'
/* SPDX-License-Identifier: Apache-2.0 */
/*
** snkv.h — Single-file amalgamation for the SNKV key-value store.
**
** Auto-generated by scripts/gen_snkv_header.sh — do not edit by hand.
**
** SNKV is a persistent, ACID-compliant key-value store built on
** SQLite's B-tree / pager / WAL engine.
**
** Usage (C) — in exactly ONE .c file:
**
**     #define SNKV_IMPLEMENTATION
**     #include "snkv.h"
**     int main() { ... }
**
** Compile (Linux/macOS):  gcc myapp.c -o myapp
** Compile (Windows/MSYS): gcc myapp.c -o myapp.exe -lws2_32
**
** Usage (C++) — compile the implementation as C, use the API from C++:
**
**     // snkv_impl.c (compile as C)
**     #define SNKV_IMPLEMENTATION
**     #include "snkv.h"
**
**     // myapp.cpp (compile as C++)
**     #include "snkv.h"
**     int main() { ... }
*/
#ifndef SNKV_H
#define SNKV_H
#pragma once

/* _GNU_SOURCE must be defined before any system headers for mremap() etc. */
#if defined(__GNUC__) && !defined(_GNU_SOURCE)
# define _GNU_SOURCE
#endif

#include <stdint.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ========== OPAQUE TYPES ========== */

typedef struct KVStore KVStore;
typedef struct KVColumnFamily KVColumnFamily;
typedef struct KVIterator KVIterator;

/* ========== ERROR CODES ========== */

#define KVSTORE_OK        0   /* Success */
#define KVSTORE_ERROR     1   /* Generic error */
#define KVSTORE_BUSY      5   /* Database file is locked (retry) */
#define KVSTORE_LOCKED    6   /* Database is locked */
#define KVSTORE_NOMEM     7   /* malloc() failed */
#define KVSTORE_READONLY  8   /* Attempt to write a read-only database */
#define KVSTORE_CORRUPT   11  /* Database file is malformed */
#define KVSTORE_NOTFOUND  12  /* Key not found */
#define KVSTORE_PROTOCOL  15  /* Database lock protocol error */

/* ========== CONSTANTS ========== */

#define KVSTORE_MAX_COLUMN_FAMILIES 64

#define KVSTORE_JOURNAL_DELETE  0   /* Delete rollback journal on commit */
#define KVSTORE_JOURNAL_WAL     1   /* Write-Ahead Logging mode */

/* Sync levels for KVStoreConfig.syncLevel */
#define KVSTORE_SYNC_OFF     0  /* No fsync — fastest, risk on power loss */
#define KVSTORE_SYNC_NORMAL  1  /* WAL-safe — default */
#define KVSTORE_SYNC_FULL    2  /* fsync every commit — power-safe */

/* ========== CONFIGURATION ========== */

/*
** Configuration structure passed to kvstore_open_v2().
** Zero-initialise and set only the fields you need.
** Unset fields (value == 0) resolve to the documented defaults.
*/
typedef struct KVStoreConfig KVStoreConfig;
struct KVStoreConfig {
  int journalMode;  /* KVSTORE_JOURNAL_WAL (default) or _DELETE        */
  int syncLevel;    /* KVSTORE_SYNC_NORMAL (default), _OFF, or _FULL   */
  int cacheSize;    /* Pages in page cache (0 = 2000 pages ≈ 8 MB)     */
  int pageSize;     /* DB page size in bytes (0 = 4096, new DBs only)   */
  int readOnly;     /* 1 = open read-only; default 0                    */
  int busyTimeout;  /* ms to retry on SQLITE_BUSY (0 = fail immediately)*/
  int walSizeLimit; /* auto-checkpoint every N commits (0 = disabled)   */
};

/* ========== STATISTICS ========== */

typedef struct KVStoreStats KVStoreStats;
struct KVStoreStats {
  uint64_t nPuts;       /* Number of put operations */
  uint64_t nGets;       /* Number of get operations */
  uint64_t nDeletes;    /* Number of delete operations */
  uint64_t nIterations; /* Number of iterators created */
  uint64_t nErrors;     /* Number of errors encountered */
};

/* ========== MEMORY HELPERS ========== */

/* Forward-declare memory functions for use in the public API macros.
** The full definitions come from the implementation section. */
#ifndef SNKV_IMPLEMENTATION
void *sqlite3MallocZero(unsigned long long);
void  sqlite3_free(void *);
#endif

#define snkv_malloc(n)  sqlite3MallocZero((unsigned long long)(n))
#define snkv_free(p)    sqlite3_free((p))

/* ========== DATABASE OPEN / CLOSE ========== */

int kvstore_open_v2(const char *zFilename, KVStore **ppKV, const KVStoreConfig *pConfig);
int kvstore_open(const char *zFilename, KVStore **ppKV, int journalMode);
int kvstore_close(KVStore *pKV);

/* ========== COLUMN FAMILY OPERATIONS ========== */

int kvstore_cf_create(KVStore *pKV, const char *zName, KVColumnFamily **ppCF);
int kvstore_cf_open(KVStore *pKV, const char *zName, KVColumnFamily **ppCF);
int kvstore_cf_get_default(KVStore *pKV, KVColumnFamily **ppCF);
int kvstore_cf_drop(KVStore *pKV, const char *zName);
int kvstore_cf_list(KVStore *pKV, char ***pazNames, int *pnCount);
void kvstore_cf_close(KVColumnFamily *pCF);

/* ========== KEY-VALUE OPERATIONS (DEFAULT CF) ========== */

int kvstore_put(KVStore *pKV, const void *pKey, int nKey, const void *pValue, int nValue);
int kvstore_get(KVStore *pKV, const void *pKey, int nKey, void **ppValue, int *pnValue);
int kvstore_delete(KVStore *pKV, const void *pKey, int nKey);
int kvstore_exists(KVStore *pKV, const void *pKey, int nKey, int *pExists);

/* ========== KEY-VALUE OPERATIONS (SPECIFIC CF) ========== */

int kvstore_cf_put(KVColumnFamily *pCF, const void *pKey, int nKey, const void *pValue, int nValue);
int kvstore_cf_get(KVColumnFamily *pCF, const void *pKey, int nKey, void **ppValue, int *pnValue);
int kvstore_cf_delete(KVColumnFamily *pCF, const void *pKey, int nKey);
int kvstore_cf_exists(KVColumnFamily *pCF, const void *pKey, int nKey, int *pExists);

/* ========== ITERATORS ========== */

int kvstore_iterator_create(KVStore *pKV, KVIterator **ppIter);
int kvstore_cf_iterator_create(KVColumnFamily *pCF, KVIterator **ppIter);
int kvstore_prefix_iterator_create(KVStore *pKV, const void *pPrefix, int nPrefix, KVIterator **ppIter);
int kvstore_cf_prefix_iterator_create(KVColumnFamily *pCF, const void *pPrefix, int nPrefix, KVIterator **ppIter);
int  kvstore_iterator_first(KVIterator *pIter);
int  kvstore_iterator_next(KVIterator *pIter);
int  kvstore_iterator_eof(KVIterator *pIter);
int kvstore_iterator_key(KVIterator *pIter, void **ppKey, int *pnKey);
int kvstore_iterator_value(KVIterator *pIter, void **ppValue, int *pnValue);
void kvstore_iterator_close(KVIterator *pIter);

/* ========== TRANSACTIONS ========== */

int kvstore_begin(KVStore *pKV, int wrflag);
int kvstore_commit(KVStore *pKV);
int kvstore_rollback(KVStore *pKV);

/* ========== UTILITIES ========== */

const char *kvstore_errmsg(KVStore *pKV);
int kvstore_stats(KVStore *pKV, KVStoreStats *pStats);
int kvstore_integrity_check(KVStore *pKV, char **pzErrMsg);
int kvstore_sync(KVStore *pKV);
int kvstore_incremental_vacuum(KVStore *pKV, int nPage);

#ifdef __cplusplus
}
#endif

PREAMBLE

# ============================================================
# Part 2: Implementation — all internal headers then all sources.
#
# sqliteInt.h includes sub-headers at specific points WITHIN the file:
#   Line 634: #include "hash.h"  /  #include "parse.h"
#   Line 1428: #include "os.h"  /  #include "pager.h"  /  #include "btree.h"
#   Line 1522: #include "pcache.h"  /  #include "mutex.h"
#
# We must interleave sub-headers at those exact positions so types
# are defined before they are used. We split sqliteInt.h into sections
# and inline the sub-headers between them.
# ============================================================

echo ""
echo "/* =================================================================="
echo "** IMPLEMENTATION"
echo "**"
echo "** Define SNKV_IMPLEMENTATION in exactly ONE .c file before including"
echo "** this header to compile the library.  All other files (including"
echo "** .cpp files) get only the public API declarations above."
echo "**"
echo "** Example:"
echo "**   // snkv_impl.c"
echo "**   #define SNKV_IMPLEMENTATION"
echo "**   #include \"snkv.h\""
echo "** ================================================================== */"
echo "#ifdef SNKV_IMPLEMENTATION"
echo ""

# --- Phase A: Headers that must come before sqliteInt.h ---
for h in msvc.h vxworks.h sqlite3.h sqliteLimit.h; do
  emit "include/$h" "$INCDIR/$h"
done

# --- Phase B: sqliteInt.h split into sections with sub-headers interleaved ---
#
# We use grep -n to find the exact line numbers of the #include directives
# so this stays correct even if sqliteInt.h is edited.

SQLITEINT="$INCDIR/sqliteInt.h"

# Find line numbers of the key #include directives
LINE_HASH=$(grep -n '#include "hash.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_PARSE=$(grep -n '#include "parse.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_OS=$(grep -n '#include "os.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_PAGER=$(grep -n '#include "pager.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_BTREE=$(grep -n '#include "btree.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_PCACHE=$(grep -n '#include "pcache.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_MUTEX=$(grep -n '#include "mutex.h"' "$SQLITEINT" | head -1 | cut -d: -f1)
LINE_END=$(wc -l < "$SQLITEINT")

echo "/****** include/sqliteInt.h (section 1: base types) ******/"
emit_lines "$SQLITEINT" 1 $((LINE_HASH - 1))

# Inline hash.h and parse.h (where sqliteInt.h line 634-635 would include them)
emit "include/hash.h" "$INCDIR/hash.h"
emit "include/parse.h" "$INCDIR/parse.h"

echo "/****** include/sqliteInt.h (section 2: after hash/parse, before os/btree) ******/"
emit_lines "$SQLITEINT" $((LINE_PARSE + 1)) $((LINE_OS - 1))

# Inline os_setup.h, os.h, pager.h, btree.h (where sqliteInt.h line 1428-1430 includes them)
emit "include/os_setup.h" "$INCDIR/os_setup.h"
emit "include/os.h" "$INCDIR/os.h"
emit "include/pager.h" "$INCDIR/pager.h"
emit "include/btree.h" "$INCDIR/btree.h"

echo "/****** include/sqliteInt.h (section 3: VDBE stubs) ******/"
emit_lines "$SQLITEINT" $((LINE_BTREE + 1)) $((LINE_PCACHE - 1))

# Inline pcache.h and mutex.h (where sqliteInt.h line 1522-1523 includes them)
emit "include/pcache.h" "$INCDIR/pcache.h"
emit "include/mutex.h" "$INCDIR/mutex.h"

echo "/****** include/sqliteInt.h (section 4: remainder) ******/"
emit_lines "$SQLITEINT" $((LINE_MUTEX + 1)) "$LINE_END"

# --- Phase C: Headers that depend on sqliteInt.h + sub-headers ---
for h in btreeInt.h wal.h os_common.h os_win.h; do
  emit "include/$h" "$INCDIR/$h"
done

# kvstore.h is already covered by the preamble.
# Set its include guard so it's skipped if any .c file tries to
# include it.  Then emit the internal compatibility macros that
# kvstore.c needs (sqliteMalloc, sqliteFree, sqliteRealloc, sqliteStrDup).
echo "#define _KVSTORE_H_"
echo ""
cat << 'COMPAT'
/****** kvstore internal compat macros ******/
#define sqliteMalloc(n)     sqlite3MallocZero((n))
#define sqliteFree(p)       sqlite3_free((p))
#define sqliteRealloc(p,n)  sqlite3Realloc((p),(u64)(n))
#define sqliteStrDup(s)     sqlite3_mprintf("%s",(s))

COMPAT

# --- Phase D: All .c source files ---
SOURCES="
  global.c
  malloc.c
  mem1.c
  util.c
  printf.c
  random.c
  fault.c
  hash.c
  rowset.c
  bitvec.c
  pcache.c
  pcache1.c
  mutex.c
  mutex_noop.c
  mutex_unix.c
  mutex_w32.c
  os.c
  os_unix.c
  os_win.c
  os_kv.c
  pager.c
  wal.c
  memjournal.c
  btree.c
  btmutex.c
  status.c
  threads.c
  kvstore.c
"

for s in $SOURCES; do
  emit "src/$s" "$CDIR/$s"
done

# ============================================================
# Part 3: Close the include guard
# ============================================================
echo "#endif /* SNKV_IMPLEMENTATION */"
echo ""
echo "#endif /* SNKV_H */"
