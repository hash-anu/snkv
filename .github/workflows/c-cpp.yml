name: C/C++ CI

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    # ---- Linux ----
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential

    # ---- macOS ----
    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        brew install make || true

    # ---- Windows (MinGW) ----
    - name: Setup MinGW on Windows
      if: runner.os == 'Windows'
      uses: msys2/setup-msys2@v2
      with:
        msystem: MINGW64
        update: true
        install: mingw-w64-x86_64-gcc make

    - name: Build
      shell: bash
      run: make

    - name: Run tests
      shell: bash
      run: make test

    - name: Clean
      if: always()
      shell: bash
      run: make clean

  # ==================================================================
  # Valgrind + memory profiling + test counting + badge publishing
  # Runs only on Linux. Publishes badge JSON to 'badges' branch.
  # ==================================================================
  valgrind:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential valgrind jq bc lcov

    - name: Build (debug mode)
      run: make BUILD=debug tests

    # ---- Run all tests under Valgrind ----
    - name: Valgrind memory leak check
      run: |
        mkdir -p badge-data
        TOTAL=0
        PASSED=0
        LEAKED=0
        LEAK_DETAILS=""

        for t in tests/test_*; do
          [ -x "$t" ] || continue
          TNAME=$(basename "$t")
          TOTAL=$((TOTAL + 1))
          echo "=== Valgrind: $TNAME ==="

          valgrind \
            --leak-check=full \
            --show-leak-kinds=all \
            --errors-for-leak-kinds=definite,indirect \
            --error-exitcode=99 \
            --log-file="valgrind-${TNAME}.log" \
            ./"$t" 2>&1 || true

          if grep -q "ERROR SUMMARY: 0 errors" "valgrind-${TNAME}.log"; then
            echo "  PASS: No memory leaks"
            PASSED=$((PASSED + 1))
          else
            echo "  FAIL: Memory leaks detected"
            LEAKED=$((LEAKED + 1))
            LEAK_DETAILS="${LEAK_DETAILS}\n--- ${TNAME} ---\n$(grep -A5 'LEAK SUMMARY' "valgrind-${TNAME}.log")"
          fi
          rm -f *.db
        done

        echo ""
        echo "=============================="
        echo "Valgrind Summary: ${PASSED}/${TOTAL} clean (${LEAKED} with leaks)"
        echo "=============================="

        if [ -n "$LEAK_DETAILS" ]; then
          echo -e "\nLeak details:${LEAK_DETAILS}"
        fi

        # Write badge data
        if [ "$LEAKED" -eq 0 ]; then
          echo '{"schemaVersion":1,"label":"memory leaks","message":"0 leaks","color":"brightgreen"}' > badge-data/valgrind.json
        else
          echo "{\"schemaVersion\":1,\"label\":\"memory leaks\",\"message\":\"${LEAKED} leaks\",\"color\":\"red\"}" > badge-data/valgrind.json
        fi

        # Fail the job if any test leaked
        [ "$LEAKED" -eq 0 ]

    # ---- Stress test with memory profiling ----
    - name: Stress test memory profiling
      run: |
        echo "=== Stress test memory profiling ==="

        # Run stress test under valgrind memcheck with --log-file
        # This gives us "total heap usage: X allocs, Y frees, Z bytes allocated"
        # which is the total bytes allocated over the lifetime of the process.
        # We also get peak RSS via /proc/self or /usr/bin/time.

        # Step 1: Get peak RSS via /usr/bin/time -v -o (writes to file directly)
        /usr/bin/time -v -o time_output.txt ./tests/test_stress || true
        rm -f *.db

        echo "--- /usr/bin/time -o output ---"
        cat time_output.txt 2>/dev/null || echo "(no output)"
        echo "-------------------------------"

        PEAK_KB=$(grep -i "maximum resident set size" time_output.txt 2>/dev/null | awk '{print $NF}')
        echo "Peak RSS from /usr/bin/time: [${PEAK_KB}] KB"

        # Step 2: Fallback — valgrind memcheck total heap
        if [ -z "$PEAK_KB" ] || [ "$PEAK_KB" = "0" ]; then
          echo "Falling back to valgrind memcheck..."
          valgrind \
            --tool=memcheck \
            --log-file=memcheck.log \
            ./tests/test_stress > /dev/null 2>&1 || true
          rm -f *.db

          echo "--- valgrind memcheck log ---"
          cat memcheck.log 2>/dev/null | tail -5
          echo "-----------------------------"

          # Extract: "total heap usage: 1,234 allocs, 1,234 frees, 5,678,901 bytes allocated"
          HEAP_LINE=$(grep "total heap usage" memcheck.log 2>/dev/null || true)
          echo "Heap line: [${HEAP_LINE}]"

          if [ -n "$HEAP_LINE" ]; then
            # Get the "bytes allocated" number, remove commas
            ALLOC_BYTES=$(echo "$HEAP_LINE" | sed 's/.*frees, *//; s/ bytes allocated.*//' | tr -d ',')
            echo "Parsed alloc bytes: [${ALLOC_BYTES}]"
            if [ -n "$ALLOC_BYTES" ] && [ "$ALLOC_BYTES" -gt 0 ] 2>/dev/null; then
              PEAK_KB=$((ALLOC_BYTES / 1024))
            fi
          fi
        fi

        # Step 3: Last fallback — /proc peak RSS (if available)
        if [ -z "$PEAK_KB" ] || [ "$PEAK_KB" = "0" ]; then
          echo "Falling back to /proc/self/status..."
          # Run test and capture VmPeak from /proc
          ./tests/test_stress &
          TEST_PID=$!
          sleep 1
          if [ -f "/proc/${TEST_PID}/status" ]; then
            VM_PEAK=$(grep VmPeak "/proc/${TEST_PID}/status" 2>/dev/null | awk '{print $2}')
            [ -n "$VM_PEAK" ] && PEAK_KB="$VM_PEAK"
          fi
          wait $TEST_PID 2>/dev/null || true
          rm -f *.db
        fi

        [ -z "$PEAK_KB" ] && PEAK_KB=0
        echo "Final PEAK_KB: ${PEAK_KB}"

        # Convert KB to human-readable
        if [ "$PEAK_KB" -ge 1048576 ] 2>/dev/null; then
          PEAK_HR="$(awk "BEGIN {printf \"%.1f\", $PEAK_KB / 1048576}") GB"
        elif [ "$PEAK_KB" -ge 1024 ] 2>/dev/null; then
          PEAK_HR="$(awk "BEGIN {printf \"%.1f\", $PEAK_KB / 1024}") MB"
        else
          PEAK_HR="${PEAK_KB} KB"
        fi

        echo ""
        echo "=============================="
        echo "Peak memory: ${PEAK_HR}"
        echo "=============================="

        echo "{\"schemaVersion\":1,\"label\":\"peak memory (stress)\",\"message\":\"${PEAK_HR}\",\"color\":\"blue\"}" > badge-data/memory.json

    # ---- Count total tests passed ----
    - name: Count tests passed
      run: |
        TOTAL_PASSED=0
        TOTAL_FAILED=0
        TOTAL_SUITES=0

        for t in tests/test_*; do
          [ -x "$t" ] || continue
          TNAME=$(basename "$t")
          TOTAL_SUITES=$((TOTAL_SUITES + 1))

          # Run test and strip ANSI color codes from output
          OUTPUT=$(./"$t" 2>&1 | sed 's/\x1b\[[0-9;]*m//g') || true
          EXIT_CODE=$?
          rm -f *.db

          echo "=== $TNAME ==="

          # Parse the passed count from summary lines.
          # Formats seen in our test suites:
          #   "Passed: 12"             (test_prod, test_stress, test_wal, etc.)
          #   "Passed:       13"       (test_mutex_journal)
          #   "Results: 5/5 passed"    (test_autovacuum)
          #   "Results: 4 passed"      (test_concurrent)
          #   "52 passed"              (test_crash_recovery)
          P=0
          F=0

          # Try "Passed: N" format first
          PASSED_LINE=$(echo "$OUTPUT" | grep -iE '^[[:space:]]*Passed:' | tail -1)
          if [ -n "$PASSED_LINE" ]; then
            P=$(echo "$PASSED_LINE" | grep -oE '[0-9]+' | head -1)
          fi

          # Try "N/N passed" format
          if [ "$P" = "0" ] || [ -z "$P" ]; then
            RESULTS_LINE=$(echo "$OUTPUT" | grep -iE '[0-9]+(/[0-9]+)? passed' | tail -1)
            if [ -n "$RESULTS_LINE" ]; then
              P=$(echo "$RESULTS_LINE" | grep -oE '[0-9]+ passed' | grep -oE '[0-9]+' | head -1)
            fi
          fi

          # Try "Failed: N" or "N failed" format
          # Extract only the number directly before "failed" or after "Failed:"
          FAILED_LINE=$(echo "$OUTPUT" | grep -iE '(^[[:space:]]*Failed:|[0-9]+ failed)' | tail -1)
          if [ -n "$FAILED_LINE" ]; then
            # Try "N failed" first
            F_MATCH=$(echo "$FAILED_LINE" | grep -oE '[0-9]+ failed' | grep -oE '[0-9]+' || true)
            if [ -z "$F_MATCH" ]; then
              # Try "Failed: N"
              F_MATCH=$(echo "$FAILED_LINE" | sed -n 's/.*[Ff]ailed:[[:space:]]*//p' | grep -oE '[0-9]+' | head -1 || true)
            fi
            [ -n "$F_MATCH" ] && F="$F_MATCH"
          fi

          # Fallback: if no summary line found, count by exit code
          if [ "$P" = "0" ] || [ -z "$P" ]; then
            if [ "$EXIT_CODE" = "0" ]; then
              P=1
            else
              F=1
            fi
          fi

          [ -z "$P" ] && P=0
          [ -z "$F" ] && F=0

          echo "  passed=$P failed=$F"
          TOTAL_PASSED=$((TOTAL_PASSED + P))
          TOTAL_FAILED=$((TOTAL_FAILED + F))
        done

        echo ""
        echo "=============================="
        echo "Tests: ${TOTAL_PASSED} passed, ${TOTAL_FAILED} failed (${TOTAL_SUITES} suites)"
        echo "=============================="

        if [ "$TOTAL_FAILED" -eq 0 ]; then
          COLOR="brightgreen"
        else
          COLOR="red"
        fi

        echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"${TOTAL_PASSED} passed\",\"color\":\"${COLOR}\"}" > badge-data/tests.json

    # ---- Upload valgrind logs on failure ----
    - name: Upload valgrind logs
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: valgrind-logs
        path: valgrind-*.log

    # ---- Code coverage (kvstore.c only) ----
    - name: Build with coverage instrumentation
      run: make BUILD=coverage tests

    - name: Run tests to generate coverage data
      run: |
        for t in tests/test_*; do
          [ -x "$t" ] || continue
          ./"$t" 2>/dev/null || true
          rm -f *.db *.db-wal *.db-shm
        done

    - name: Extract kvstore.c coverage
      run: |
        lcov --capture --directory src --output-file coverage.info
        lcov --extract coverage.info '*/src/kvstore.c' --output-file coverage_kvstore.info
        lcov --summary coverage_kvstore.info

    - name: Upload to Codecov
      uses: codecov/codecov-action@v5
      with:
        files: coverage_kvstore.info
        flags: kvstore
        name: kvstore-coverage

    # ---- Publish badge JSON files to 'badges' branch ----
    - name: Publish badges to badges branch
      if: github.ref == 'refs/heads/master' && github.event_name == 'push'
      run: |
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Save badge data
        cp -r badge-data /tmp/badge-data

        # Create or switch to orphan 'badges' branch
        git fetch origin badges 2>/dev/null || true
        if git rev-parse --verify origin/badges >/dev/null 2>&1; then
          git checkout badges
        else
          git checkout --orphan badges
          git rm -rf . 2>/dev/null || true
        fi

        # Copy badge JSON files
        cp /tmp/badge-data/*.json .

        # Commit and push
        git add valgrind.json tests.json memory.json
        git diff --cached --quiet && echo "No badge changes" && exit 0
        git commit -m "Update badges [skip ci]"
        git push origin badges
